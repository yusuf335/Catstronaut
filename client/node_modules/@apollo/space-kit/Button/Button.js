'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _tslib = require('../_tslib-bcbe0269.js');
var core = require('@emotion/core');
var React = require('react');
var React__default = _interopDefault(React);
require('../fonts/fonts.js');
var base$1 = require('../base-91f9e1df.js');
require('../mono-a0d4bd30.js');
var colors = require('../colors/colors.js');
var assertUnreachable = require('../assertUnreachable-698a501a.js');
var index = require('../SpaceKitProvider/index.js');
require('../colors/utils/findPaletteByColor.js');
var getOffsetInPalette = require('../colors/utils/getOffsetInPalette.js');
var tinycolor = _interopDefault(require('tinycolor2'));
var LoadingSpinner = require('../Loaders/LoadingSpinner.js');
var focus = require('@react-aria/focus');
var utils = require('@react-aria/utils');
var omit = _interopDefault(require('lodash/omit'));
var ButtonIcon = require('./button/ButtonIcon.js');
var inputHeightDictionary = require('../inputHeightDictionary-78849349.js');
var TooltipContext = require('../TooltipContext-20cc2d3d.js');

/**
 * Save a default color so we can check if we used the default or not. The
 * default color has a few special properties.
 */

var defaultColor = colors.colors.silver.light;
/**
 * Get the button's text color
 */

function getTextColor(_a) {
  var color = _a.color,
      feel = _a.feel,
      theme = _a.theme,
      mode = _a.mode; // Text color will always be the same for secondary buttons

  if (color === colors.colors.white) {
    return colors.colors.grey.darker;
  }

  switch (feel) {
    case "raised":
      // Set the base (meaning no pseudo-selectors) text color for raised
      // buttons. Otherwise return `undefined` to not change the color.
      //
      // We have some special logic for the raised color; set the text color to
      // be what is most readable between white and the default text color and
      // the _hover_ color's background. This is overrideable by the user, but
      // it shouldn't need to be.
      return !mode ? tinycolor.mostReadable(getHoverBackgroundColor({
        color: color,
        feel: feel,
        theme: theme
      }), [colors.colors.white, colors.colors.grey.darker], {
        level: "AA",
        size: "small"
      }).toString() : undefined;

    case "flat":
      if (color === defaultColor) {
        return theme === "dark" ? colors.colors.grey.light : colors.colors.grey.darker;
      } // We have a custom color and we're in dark mode, lighten the base and
      // focused colors 1 shade.


      if (theme === "dark" && (!mode || mode === ":focus")) {
        return getOffsetInPalette.getOffsetInPalette(1, "lighter", color);
      }

      return color;

    /* istanbul ignore next */

    default:
      throw assertUnreachable.assertUnreachable(feel);
  }
}
/**
 * Get the button's height
 */


function getHeight(_a) {
  var size = _a.size;

  switch (size) {
    case "small":
      return 28;

    case "default":
    case "standard":
      return 36;

    case "large":
      return 42;

    /* istanbul ignore next */

    default:
      throw assertUnreachable.assertUnreachable(size);
  }
}
/**
 * Get the hover background color
 */


function getHoverBackgroundColor(_a) {
  var color = _a.color,
      feel = _a.feel,
      theme = _a.theme;

  if (color === colors.colors.white) {
    // Special case for secondary buttons
    return colors.colors.silver.light;
  }

  switch (feel) {
    case "flat":
      // Hardcode if we're using the default color (special case), otherwise get
      // the next lightest color.
      if (color === defaultColor) {
        return theme === "light" ? colors.colors.silver.light : colors.colors.grey.dark;
      }

      return getOffsetInPalette.getOffsetInPalette(Infinity, "lighter", color);

    case "raised":
      // One shade darker
      return getOffsetInPalette.getOffsetInPalette(1, "darker", color);

    /* istanbul ignore next */

    default:
      throw assertUnreachable.assertUnreachable(feel);
  }
}
/**
 * Style system for Space Kit buttons
 *
 * This is intended to be used as an abstraction for your project's style guide.
 *
 * @see https://zpl.io/amdN6Pr
 */


var Button = /*#__PURE__*/React__default.forwardRef(function (_a, ref) {
  var _b = _a.as,
      as = _b === void 0 ? core.jsx("button", null) : _b,
      children = _a.children,
      _c = _a.color,
      color = _c === void 0 ? defaultColor : _c,
      variant = _a.variant,
      endIcon = _a.endIcon,
      _d = _a.feel,
      feel = _d === void 0 ? "raised" : _d,
      iconProp = _a.icon,
      loading = _a.loading,
      _e = _a.size,
      size = _e === void 0 ? "standard" : _e,
      propTheme = _a.theme,
      passthroughProps = _tslib.__rest(_a, ["as", "children", "color", "variant", "endIcon", "feel", "icon", "loading", "size", "theme"]);

  if (size === "default") {
    size = "standard";
  }

  var _f = focus.useFocusRing(),
      isFocusVisible = _f.isFocusVisible,
      focusProps = _f.focusProps;

  var providerTheme = index.useSpaceKitProvider().theme;
  var theme = propTheme || providerTheme; // Capture if the mouse is over the button by using `onPointerEnter` and
  // `onPointerLeave`, which will still fire if the button is disabled. When
  // we know the cursor is over the button, then override the button's
  // `disabled` behavior to allow `Tooltip`s to work.

  var _g = React.useState(false),
      isPointerOver = _g[0],
      setIsPointerOver = _g[1];

  var mergedProps = utils.mergeProps(passthroughProps, as.props, focusProps, {
    ref: ref
  });
  /**
   * If the button is in a `loading` state, then always treat the button as
   * disabled.
   */

  if (loading) {
    mergedProps.disabled = true;
  }
  /**
   * Flag indicating we're going to override the default disabled behavior to
   * make an antecedent `Tooltip` work
   */


  var overrideDisabledBehavior = TooltipContext.useTooltipContext().descendsFromTooltip && isPointerOver && mergedProps.disabled;
  /**
   * Handler to avoid responding to click events for all attached listeners
   * when `disabled`
   */

  var onClick = function (event) {
    var _a; // If the button is disabled, then don't propogate `onClick`
    // events.


    if (mergedProps.disabled) return event.preventDefault();
    (_a = mergedProps.onClick) === null || _a === void 0 ? void 0 : _a.call(mergedProps, event);
  };
  /**
   * Styles to apply when button is disabled.
   *
   * We store this because we use this in multiple places to account for
   * overriding the default disabled behavior.
   */


  var disabledStyles = {
    backgroundColor: feel === "flat" ? "transparent" : theme === "light" ? colors.colors.silver.light : colors.colors.grey.dark,
    boxShadow: "none",
    color: feel === "flat" && theme === "dark" ? colors.colors.grey.dark : colors.colors.grey.light
  };

  var focusedStyles = _tslib.__assign(_tslib.__assign({}, feel === "flat" && {
    backgroundColor: theme === "light" ? colors.colors.white : "#000",
    color: theme === "light" ? colors.colors.blue.base : colors.colors.blue.light
  }), {
    // The `box-shadow` property is copied directly from Zeplin for the
    // light theme. For the dark theme we use a variant of the color to
    // make the borders sharp.
    boxShadow: "0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 0 0 2px " + (theme === "light" || color === defaultColor || color === colors.colors.white ? "#bbdbff" : getOffsetInPalette.getOffsetInPalette(Infinity, "lighter", color)) + ", inset 0 0 0 1px " + (color === defaultColor || color === colors.colors.white ? "#2075d6" : getOffsetInPalette.getOffsetInPalette(1, "darker", color)) + ", inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)"
  });

  var icon = loading ? core.jsx(LoadingSpinner.LoadingSpinner, {
    size: "2xsmall",
    theme: theme === "light" ? "grayscale" : "dark"
  }) : iconProp;
  /**
   * Icon size in pixels
   *
   * This is stored so we can use the same value for `height` and `width`
   */

  var iconSize = size === "small" ? 12 : size === "large" ? 24 : 16;
  var iconOnly = !children;

  if (variant === "fab") {
    if (!icon) {
      throw new TypeError("FAB buttons are required to have an `icon`");
    } else if (children) {
      throw new TypeError("FAB buttons cannot have children, only an `icon`");
    }
  }

  return core.jsx(core.ClassNames, null, function (_a) {
    var cx = _a.cx,
        css = _a.css;
    var propsToPass = utils.mergeProps( // Omit `onClick` from `otherProps` beacuse we'll be conditionally
    // calling it in the `onClick` handler depending on `mergedProps.disabled`.
    // Also exclude `className` beacuse we'll be combining it on
    // our own with `cx`. This is necessary because `cx` allows for
    // emotion styles to be logically overwritten.
    omit(mergedProps, "className", "onClick", // If we're overriding the default disabled behavior, then strip
    // it out from the props we'll pass to the element.
    overrideDisabledBehavior ? "disabled" : ""), {
      "aria-disabled": mergedProps.disabled,
      onClick: onClick,
      onPointerEnter: function () {
        setIsPointerOver(true);
      },
      onPointerLeave: function () {
        setIsPointerOver(false);
      },
      className: cx(css([{
        "&:focus": {
          outline: 0
        }
      }, _tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign({
        backgroundColor: color === colors.colors.white ? colors.colors.white : feel === "raised" ? color : "transparent",
        borderRadius: variant === "fab" ? "100%" : 4,
        borderWidth: 0
      }, feel !== "flat" && {
        boxShadow: theme === "light" ? "0 1px 4px 0 rgba(18, 21, 26, 0.04), inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)" : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 1px 0 0 rgba(18, 21, 26, 0.05)"
      }), {
        color: getTextColor({
          color: color,
          feel: feel,
          theme: theme
        }),
        cursor: mergedProps.disabled ? "default" : "pointer",
        // Vertically center children
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        height: getHeight({
          size: size
        }),
        minWidth: iconOnly ? inputHeightDictionary.inputHeightDictionary[size === "default" ? "standard" : size] : endIcon ? 0 : size === "small" ? 76 : size === "default" || size === "standard" ? 100 : size === "large" ? 112 : assertUnreachable.assertUnreachable(size),
        // We have to set the Y padding because browsers (at least Chrome) has
        // a non-symmetrical vertical padding applied by default.
        paddingLeft: iconOnly ? 0 : 12,
        paddingRight: iconOnly ? 0 : endIcon ? 8 : 12
      }), size === "small" ? base$1.small : size === "large" ? base$1.large : base$1.base), {
        fontWeight: 600,
        // Disable the outline because we're setting a custom `:active` style
        outline: 0,
        textDecoration: "none",
        whiteSpace: "nowrap"
      }), // We need to also set the `:hover` on `:disabled` so it has a
      // higher specificity than any `:hover` classes passed in. This
      // also means that both of these need to be overriden if we want
      // to use a custom disabled color.
      mergedProps.disabled ? overrideDisabledBehavior ? disabledStyles : {
        "&[disabled], &[disabled]:hover": disabledStyles
      } : {
        ":hover, &[data-force-hover-state]": _tslib.__assign({
          backgroundColor: getHoverBackgroundColor({
            color: color,
            feel: feel,
            theme: theme
          }),
          color: getTextColor({
            color: color,
            feel: feel,
            theme: theme,
            mode: ":hover"
          })
        }, feel !== "flat" && {
          // The `box-shadow` property is copied directly from Zeplin
          boxShadow: theme === "light" ? "0 5px 10px 0 rgba(18, 21, 26, 0.08), inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)" : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 5px 10px 0 rgba(18, 21, 26, 0.12), 0 1px 0 0 rgba(18, 21, 26, 0.05)"
        }),
        // This is kind of hacky behavior
        "&[data-force-focus-state]": focusedStyles,
        "&:active, &[data-force-active-state], &[aria-expanded=true]": _tslib.__assign(_tslib.__assign({}, getTextColor({
          color: color,
          feel: feel,
          theme: theme,
          mode: ":hover"
        }) && {
          color: getTextColor({
            color: color,
            feel: feel,
            theme: theme,
            mode: ":active"
          })
        }), {
          backgroundColor: color === colors.colors.white ? colors.colors.white : feel === "raised" ? color : color === defaultColor ? theme === "dark" ? colors.colors.grey.darker : colors.colors.silver.base : getOffsetInPalette.getOffsetInPalette(2, "lighter", color),
          // The `box-shadow` properties are copied directly from Zeplin
          boxShadow: feel !== "flat" ? theme === "light" ? "inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05), inset 0 2px 2px 0 rgba(18, 21, 26, 0.12)" : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 -1px 0 0 rgba(18, 21, 26, 0.16), inset 0 1px 2px 0 rgba(18, 21, 26, 0.42)" : "none",
          outline: "0"
        })
      }]), mergedProps.className, isFocusVisible && css(focusedStyles)),
      children: core.jsx(React__default.Fragment, null, icon && core.jsx(ButtonIcon.ButtonIcon, {
        iconSize: iconSize,
        className: css({
          margin: iconOnly ? 0 : "0 8px 0 0"
        })
      }, icon), children, endIcon && !loading && core.jsx(ButtonIcon.ButtonIcon, {
        iconSize: iconSize,
        className: css({
          margin: iconOnly ? 0 : "0 0 0 6px"
        })
      }, endIcon))
    });
    return /*#__PURE__*/React__default.cloneElement(as, propsToPass);
  });
});

exports.Button = Button;
//# sourceMappingURL=Button.js.map
