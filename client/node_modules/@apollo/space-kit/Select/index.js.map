{"version":3,"file":"index.js","sources":["../src/Select/index.tsx"],"sourcesContent":["/** @jsx jsx */\n/** @jsxFrag React.Fragment */\nimport React, { ChangeEvent, FocusEvent, RefCallback } from \"react\";\nimport { Button } from \"../Button\";\nimport { colors } from \"../colors\";\nimport { IconArrowDown } from \"../icons/IconArrowDown\";\nimport { List } from \"../List\";\nimport { ListItem } from \"../ListItem\";\nimport { ListHeading } from \"../ListHeading\";\nimport { ListDivider } from \"../ListDivider\";\nimport { Popover } from \"../Popover\";\nimport { useSelect, UseSelectPropGetters } from \"downshift\";\nimport { ClassNames, jsx } from \"@emotion/core\";\nimport {\n  reactNodeToDownshiftItems,\n  isHTMLOptionElement,\n  isHTMLOptgroupElement,\n} from \"./select/reactNodeToDownshiftItems\";\nimport { ListConfigProvider, useListConfig } from \"../ListConfig\";\nimport { As, createElementFromAs } from \"../shared/createElementFromAs\";\nimport useDeepCompareEffect from \"use-deep-compare-effect\";\nimport { inputHeightDictionary } from \"../shared/inputHeightDictionary\";\nimport { useFormControlContext } from \"../FormControl\";\nimport { getEffectiveValueFromOptionElementProps } from \"./select/getEffectiveValueFromOptionElementProps\";\nimport { IconCheck } from \"../icons/IconCheck\";\n\nexport type OptionProps = React.DetailedHTMLProps<\n  React.OptionHTMLAttributes<HTMLOptionElement>,\n  HTMLOptionElement\n>;\n\n// This is defined in it's own interface so that both interfaces that will use\n// it can `extend` this interface, therefore automatically including the jsdoc\n// in both types.\ninterface RenderListItemProps {\n  /**\n   * Custom function to render each `ListItem`\n   *\n   * This is provided so you can render the `ListItem` on your own, with an `as`\n   * prop, for example, so you can render a `Link`. \n   *\n   * The function will be called and it's return value rendered; this does not\n   * use `React.createElement`, so an inline function is totally acceptable with\n   * no performance penalty.\n   *\n   * @default `(props) => <ListItem {...props} />`\n   *\n   *\n   * @param props - Props that were going to be passed to the underlying\n   *`ListItem`. You must merge this with whatever you are going to render.\n\n   * @param optionElement - The `option` element that is going to be parsed and\n   * rendered as a `ListItem`.\n   *\n   * You can use this to get the props you passed to the `option` element so you\n   * can customize behavior. For example, you can use this to extract the\n   * `option`'s `value` prop and generate a custom URL with `Link` element.\n   */\n  renderListItem: (\n    props: React.ComponentProps<typeof ListItem>,\n    optionElement: React.ReactElement<\n      React.DetailedHTMLProps<\n        React.OptionHTMLAttributes<HTMLOptionElement>,\n        HTMLOptionElement\n      >,\n      \"option\"\n    >,\n  ) => React.ReactElement<React.ComponentProps<typeof ListItem>>;\n}\n\ninterface ListItemWrapperProps\n  extends Pick<Props, \"selectionIndicator\">,\n    RenderListItemProps {\n  /** `items` prop passed to `useSelect`\n   *\n   * We'll use this to get the index\n   */\n  downshiftItems: OptionProps[];\n  element: React.ReactElement<OptionProps, \"option\">;\n  /** Passthrough downshift function to get the props for an item */\n  getItemProps: UseSelectPropGetters<OptionProps>[\"getItemProps\"];\n  selected: boolean;\n  className?: string;\n}\n\n/**\n * Abstraction to handle rendering `ListItem`s with downshift props\n */\nconst ListItemWrapper: React.FC<ListItemWrapperProps> = ({\n  downshiftItems,\n  element,\n  getItemProps,\n  renderListItem,\n  selected,\n  selectionIndicator,\n  className,\n}) => {\n  const index = downshiftItems.indexOf(element.props);\n\n  if (index === -1) {\n    throw new Error(\n      \"Development error: props must be passed by reference in `reactNodeToDownshiftItems` so they can be found with `Array.prototype.indexOf`\",\n    );\n  }\n\n  const downshiftItemProps = getItemProps({\n    item: element.props,\n    index: downshiftItems.indexOf(element.props),\n    disabled: element.props.disabled,\n  });\n\n  return (\n    <ClassNames>\n      {({ css, cx }) => {\n        return renderListItem(\n          {\n            className: cx(css({ alignItems: \"baseline\" }), className),\n            key: element.props.value || element.props.children,\n            ...downshiftItemProps,\n            highlighted: downshiftItemProps[\"aria-selected\"] === \"true\",\n            selected,\n            startIcon:\n              selectionIndicator === \"checkmark\" ? (\n                selected ? (\n                  <IconCheck css={{ height: \"100%\", width: \"100%\" }} />\n                ) : null\n              ) : undefined,\n            children: element.props.children,\n          },\n          element,\n        );\n      }}\n    </ClassNames>\n  );\n};\n\ninterface Props\n  extends Pick<\n      React.ComponentProps<typeof Popover>,\n      | \"disabled\"\n      | \"maxWidth\"\n      | \"placement\"\n      | \"popperOptions\"\n      | \"matchTriggerWidth\"\n    >,\n    Pick<\n      React.ComponentProps<typeof Button>,\n      \"aria-labelledby\" | \"aria-describedby\" | \"feel\" | \"style\" | \"color\"\n    >,\n    Pick<\n      React.ComponentProps<typeof ListConfigProvider>,\n      \"margin\" | \"truncate\"\n    >,\n    Pick<\n      React.DetailedHTMLProps<\n        React.SelectHTMLAttributes<HTMLSelectElement>,\n        HTMLSelectElement\n      >,\n      \"onBlur\" | \"onChange\" | \"name\"\n    >,\n    Partial<RenderListItemProps> {\n  /**\n   * class name to apply to the trigger component\n   */\n  className?: string;\n  /**\n   * `RefCallback` for props that should be spread onto a `label` component\n   * associated with this `Select`.\n   *\n   * The value will be calculated internally by `downshift`; so get the value\n   * and call this callback. This callback will only be called when the values\n   * change by a deep comparission (via\n   * [`use-deep-compare-effect`](https://github.com/kentcdodds/use-deep-compare-effect));\n   * not by `Object.is`. Therefore it's safe to save this entire value in state\n   * and spread it onto a label without fear of more than one re-render.\n   *\n   * Example:\n   *\n   * ```\n   * import * as React from 'react';\n   *\n   * export const SelectWithLabel: React.FC = () => {\n   *   const [labelProps, setLabelProps] = React.useState();\n   *\n   *   return (\n   *     <React.Fragment>\n   *       <label {...labelProps}>select label</label>\n   *       <Select\n   *         labelPropsCallbackRef={setLabelProps}\n   *         ...\n   *       >\n   *          ...\n   *       </Select>\n   *     </React.Fragment>\n   *   );\n   * }\n   * ```\n   */\n  labelPropsCallbackRef?: RefCallback<\n    ReturnType<UseSelectPropGetters<OptionProps>[\"getLabelProps\"]>\n  >;\n  /**\n   * ID is an optional field used to formulaicly add accessability props as\n   * follows:\n   *\n   * - The trigger button will be given the this `id`\n   * - The list will be given ```${id}-menu```\n   *\n   * If this field is not included or is `undefined`, the automatic downshift\n   * props will be used.\n   *\n   * The list and trigger button will also be assigned the value of\n   * `aria-labelledby`\n   */\n  id?: string | undefined;\n\n  /**\n   * Used to override how the underlying `List` is rendered\n   *\n   * This is useful when need to customize the list behavior\n   *\n   * @default <List />\n   */\n  listAs?: React.ReactElement<React.ComponentProps<typeof List>>;\n\n  /**\n   * Render prop function to generate a `React.ReactNode` based on the currently\n   * selected value.\n   *\n   * This is useful when you want some custom behavior with what is shown in the\n   * select in the unopened state.\n   */\n  renderTriggerNode?: (value: OptionProps | null) => React.ReactNode;\n\n  triggerAs?: As;\n\n  /**\n   * Item currently selected\n   *\n   * While I believe it's also valid to use the `<option>`'s `selected` prop; we\n   * are not using that here. We _might_ use that if we render a native `select`\n   * element in the future.\n   */\n  value?: NonNullable<OptionProps[\"value\"]> | null;\n\n  /** Initial value for a non-controlled component */\n  defaultValue?: NonNullable<OptionProps[\"value\"]> | null;\n\n  /**\n   * Indicates decoration for the selected item\n   *\n   * Note, this is for an item that is selected; _not_ the item that is\n   * highlighted.\n   *\n   * Options:\n   *\n   * * `checkmark` will place a checkmark to the left\n   */\n  selectionIndicator?: \"checkmark\" | null;\n\n  size?: keyof typeof inputHeightDictionary;\n}\n\nexport const Select: React.FC<Props> = ({\n  children,\n  className,\n  defaultValue,\n  disabled = false,\n  feel,\n  color = colors.white,\n  labelPropsCallbackRef,\n  listAs = <List startIconAs={<div css={{ alignSelf: \"baseline\" }} />} />,\n  margin = \"auto\",\n  matchTriggerWidth,\n  onBlur,\n  onChange,\n  placement = \"bottom-start\",\n  popperOptions,\n  renderListItem = (props) => <ListItem {...props} />,\n  renderTriggerNode = (value) => <>{value?.children || \"\"}</>,\n  selectionIndicator = null,\n  size = \"standard\",\n  triggerAs = <Button />,\n  truncate = true,\n  value: valueProp,\n  maxWidth,\n  ...props\n}) => {\n  const {\n    describedBy: formControlDescribedBy,\n    hasError,\n    id: formControlId,\n    labelledBy: formControlLabelledBy,\n  } = useFormControlContext();\n\n  const id = props.id ?? formControlId;\n  const describedBy = props[\"aria-describedby\"] ?? formControlDescribedBy;\n  const labelledBy = props[\"aria-labelledby\"] ?? formControlLabelledBy;\n\n  const [uncontrolledValue, setUncontrolledValue] = React.useState(\n    defaultValue ?? \"\",\n  );\n\n  // Validate controlled versus uncontrolled\n  if (\n    (typeof onChange !== \"undefined\" || typeof valueProp !== \"undefined\") &&\n    typeof defaultValue !== \"undefined\"\n  ) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"Select component must be either controlled or uncontrolled. Pass either `defaultValue` for an uncontrolled component or `value` and optionally `onChange` for a controlled component.\",\n    );\n  }\n\n  const value =\n    typeof valueProp !== \"undefined\" ? valueProp : uncontrolledValue;\n\n  /**\n   * Reference to the underlying popper instance\n   *\n   * We'll use this to control the popover's visbility based on events captured\n   * by downshift\n   */\n  const instanceRef = React.useRef<\n    Parameters<NonNullable<React.ComponentProps<typeof Popover>[\"onCreate\"]>>[0]\n  >();\n\n  const listConfig = useListConfig();\n\n  /**\n   * Items data represtented by the DOM structure in `children`\n   */\n  const items = reactNodeToDownshiftItems(children);\n\n  /**\n   * Ref stored for a timeout that's initiated after a `ToggleButtonClick` state\n   * change. It'll automatically clear itself after the timeout. Use this ref\n   * containing a value to mean that there was a `ToggleButtonClick` state\n   * change in the last tick.\n   */\n  const toggleButtonClickTimeout = React.useRef<number | undefined>();\n\n  /**\n   * Wrapper to call `onBlur`\n   *\n   * Will attempt to simulate a real event.\n   */\n  const blur = () => {\n    const target = { ...props, value };\n\n    onBlur?.(({\n      type: \"blur\",\n      currentTarget: target,\n      target,\n    } as unknown) as FocusEvent<HTMLSelectElement>);\n  };\n\n  const {\n    getLabelProps,\n    getItemProps,\n    getMenuProps,\n    getToggleButtonProps,\n    selectedItem,\n  } = useSelect<OptionProps>({\n    stateReducer(state, actionAndChanges) {\n      switch (actionAndChanges.type) {\n        case useSelect.stateChangeTypes.MenuMouseLeave:\n        case useSelect.stateChangeTypes.MenuBlur: {\n          /**\n           * Indicates if the element that we \"blur\"'ed to is a descendent of\n           * the tooltip. If it is, then we should bypass the closing behavior.\n           */\n          const popperContainsActiveElement = !!instanceRef.current?.popper?.contains(\n            document.activeElement,\n          );\n\n          return {\n            ...actionAndChanges.changes,\n            isOpen: popperContainsActiveElement,\n          };\n        }\n        default:\n          return actionAndChanges.changes;\n      }\n    },\n    onStateChange(changes) {\n      switch (changes.type) {\n        case useSelect.stateChangeTypes.MenuMouseLeave:\n        case useSelect.stateChangeTypes.MenuBlur: {\n          /**\n           * Indicates if the element that we \"blur\"'ed to is a descendent of\n           * the tooltip. If it is, then we should bypass the closing behavior.\n           */\n          const popperContainsActiveElement = !!instanceRef.current?.popper?.contains(\n            document.activeElement,\n          );\n\n          if (!popperContainsActiveElement) blur();\n          break;\n        }\n        case useSelect.stateChangeTypes.ToggleButtonClick:\n          window.clearTimeout(toggleButtonClickTimeout.current);\n          toggleButtonClickTimeout.current = window.setTimeout(() => {\n            toggleButtonClickTimeout.current = undefined;\n          }, 0);\n          break;\n      }\n    },\n    items,\n    scrollIntoView(node) {\n      // We have to defer this call until the popover has been created. I really\n      // don't have a great explanation for this; but this works and I can't see\n      // a downside because the extra complexity.\n      setTimeout(() => {\n        // It's silly to write code for our tests, but `scrollIntoView` doesn't\n        // exist in JSDOM, so we have to make sure we don't call it on tests or\n        // they'll break.\n        node.scrollIntoView?.({\n          behavior: \"auto\",\n          block: \"nearest\",\n          inline: \"nearest\",\n        });\n      }, 0);\n    },\n    selectedItem:\n      items.find((item) => {\n        return value === (item.value ?? item.children);\n      }) ?? null,\n    onSelectedItemChange: (event) => {\n      const newValue = event.selectedItem\n        ? getEffectiveValueFromOptionElementProps(event.selectedItem)\n        : \"\";\n\n      if (onChange) {\n        // This is kind of hacky because there's no underlying `select` with\n        // native events firing. Maybe we should create them and then fire\n        // events?\n        const target = { ...props, value: newValue };\n\n        onChange(({\n          currentTarget: target,\n          target,\n        } as unknown) as ChangeEvent<HTMLSelectElement>);\n      } else {\n        setUncontrolledValue(newValue);\n      }\n    },\n    onIsOpenChange: (event) => {\n      if (event.isOpen) {\n        instanceRef.current?.show();\n      } else {\n        instanceRef.current?.hide();\n      }\n    },\n  });\n\n  // Get the label's props and call the callback ref when they change.\n  const labelProps = getLabelProps();\n  useDeepCompareEffect(() => {\n    labelPropsCallbackRef?.(labelProps);\n  }, [labelProps, labelPropsCallbackRef]);\n\n  return (\n    <ListConfigProvider {...listConfig} iconSize=\"small\">\n      <ClassNames>\n        {({ css, cx }) => (\n          <Popover\n            popperOptions={popperOptions}\n            onCreate={(instance) => {\n              instanceRef.current = instance;\n            }}\n            content={React.cloneElement(\n              listAs,\n              {\n                margin,\n                truncate,\n                ...getMenuProps(undefined, { suppressRefError: true }),\n                ...(id && { id: `${id}-menu` }),\n                \"aria-labelledby\": labelledBy,\n                \"aria-describedby\": describedBy,\n              },\n              React.Children.toArray(children)\n                // Filter out falsy elements in `children`. We need to know if\n                // we're rendering the first actual element in `children` to\n                // know if we should add a divider or not. If the consumer uses\n                // conditional logic in their rendering then we could have\n                // `undefined` elements in `children`.\n                .filter(\n                  (child): child is NonNullable<React.ReactNode> => !!child,\n                )\n                .map((child, topLevelIndex) => {\n                  if (isHTMLOptionElement(child)) {\n                    return (\n                      <ListItemWrapper\n                        className={child.props.className}\n                        data-top-level-index={topLevelIndex}\n                        downshiftItems={items}\n                        element={child}\n                        getItemProps={getItemProps}\n                        renderListItem={renderListItem}\n                        selected={selectedItem === child.props}\n                        selectionIndicator={selectionIndicator}\n                        key={getEffectiveValueFromOptionElementProps(\n                          child.props,\n                        )}\n                      />\n                    );\n                  } else if (isHTMLOptgroupElement(child)) {\n                    return (\n                      <React.Fragment key={child.props.label}>\n                        {topLevelIndex > 0 && (\n                          <ListDivider data-top-level-index={topLevelIndex} />\n                        )}\n                        {child.props.label && (\n                          <ListHeading\n                            aria-label={child.props.label}\n                            role=\"group\"\n                          >\n                            {child.props.label}\n                          </ListHeading>\n                        )}\n                        {React.Children.map(\n                          child.props.children as React.ReactElement<\n                            OptionProps,\n                            \"option\"\n                          >[],\n                          (optgroupChild) => {\n                            return (\n                              <ListItemWrapper\n                                key={getEffectiveValueFromOptionElementProps(\n                                  optgroupChild.props,\n                                )}\n                                downshiftItems={items}\n                                element={optgroupChild}\n                                getItemProps={getItemProps}\n                                renderListItem={renderListItem}\n                                selectionIndicator={selectionIndicator}\n                                selected={selectedItem === optgroupChild.props}\n                              />\n                            );\n                          },\n                        )}\n                      </React.Fragment>\n                    );\n                  }\n\n                  return null;\n                }),\n            )}\n            hideOnClick={false}\n            placement={placement}\n            triggerEvents=\"manual\"\n            matchTriggerWidth={matchTriggerWidth}\n            trigger={React.cloneElement(\n              createElementFromAs(triggerAs),\n              {\n                ...getToggleButtonProps({ disabled }),\n                ...props,\n                ...(labelledBy && { \"aria-labelledby\": labelledBy }),\n                id,\n                className: cx(\n                  css({\n                    border: hasError\n                      ? `1px solid ${colors.red.base}`\n                      : undefined,\n                    textAlign: \"left\",\n                  }),\n                  className,\n                  React.isValidElement(triggerAs) &&\n                    (triggerAs.props as any).className,\n                ),\n                color,\n                feel,\n                onBlur() {\n                  if (toggleButtonClickTimeout.current) {\n                    // There was a `ToggleButtonClick` state change in the last\n                    // tick, so ignore this blur call.\n                    return;\n                  }\n\n                  blur();\n                },\n                type: \"button\",\n                size,\n\n                endIcon: (\n                  <IconArrowDown\n                    className={css({ height: \"70%\" })}\n                    weight=\"thin\"\n                  />\n                ),\n              },\n              <div\n                className={css({\n                  flex: 1,\n                  overflow: \"hidden\",\n                  whiteSpace: \"nowrap\",\n                  textOverflow: \"ellipsis\",\n                })}\n              >\n                {renderTriggerNode(selectedItem)}\n              </div>,\n            )}\n            maxWidth={maxWidth}\n          />\n        )}\n      </ClassNames>\n    </ListConfigProvider>\n  );\n};\n"],"names":["ListItemWrapper","_a","downshiftItems","element","getItemProps","renderListItem","selected","selectionIndicator","className","index","indexOf","props","Error","downshiftItemProps","item","disabled","jsx","ClassNames","css","cx","alignItems","key","value","children","highlighted","startIcon","IconCheck","height","width","undefined","Select","defaultValue","_f","feel","_g","color","colors","white","labelPropsCallbackRef","_h","listAs","List","startIconAs","alignSelf","_j","margin","matchTriggerWidth","onBlur","onChange","_k","placement","popperOptions","_l","ListItem","_m","renderTriggerNode","_o","_p","size","_q","triggerAs","Button","_r","truncate","valueProp","maxWidth","_s","useFormControlContext","formControlDescribedBy","hasError","formControlId","formControlLabelledBy","id","describedBy","labelledBy","_t","React","useState","uncontrolledValue","setUncontrolledValue","console","warn","instanceRef","useRef","listConfig","useListConfig","items","reactNodeToDownshiftItems","toggleButtonClickTimeout","blur","target","type","currentTarget","_u","useSelect","stateReducer","state","actionAndChanges","stateChangeTypes","MenuMouseLeave","MenuBlur","popperContainsActiveElement","current","popper","contains","document","activeElement","changes","isOpen","onStateChange","ToggleButtonClick","window","clearTimeout","setTimeout","scrollIntoView","node","behavior","block","inline","selectedItem","find","onSelectedItemChange","event","newValue","getEffectiveValueFromOptionElementProps","onIsOpenChange","show","hide","getLabelProps","getMenuProps","getToggleButtonProps","labelProps","useDeepCompareEffect","ListConfigProvider","iconSize","Popover","onCreate","instance","content","cloneElement","suppressRefError","Children","toArray","filter","child","map","topLevelIndex","isHTMLOptionElement","isHTMLOptgroupElement","Fragment","label","ListDivider","ListHeading","role","optgroupChild","hideOnClick","triggerEvents","trigger","createElementFromAs","border","red","base","textAlign","isValidElement","endIcon","IconArrowDown","weight","flex","overflow","whiteSpace","textOverflow"],"mappings":"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"}