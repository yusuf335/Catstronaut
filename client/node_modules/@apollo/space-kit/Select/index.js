'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _tslib = require('../_tslib-bcbe0269.js');
var core = require('@emotion/core');
var React = require('react');
var React__default = _interopDefault(React);
require('../fonts/fonts.js');
require('../base-91f9e1df.js');
require('../mono-a0d4bd30.js');
var colors = require('../colors/colors.js');
require('../assertUnreachable-698a501a.js');
require('../SpaceKitProvider/index.js');
require('classnames');
require('../colors/utils/findPaletteByColor.js');
require('../colors/utils/getOffsetInPalette.js');
require('tinycolor2');
require('../Loaders/LoadingSpinner.js');
require('@react-aria/focus');
require('@react-aria/utils');
require('lodash/omit');
require('../Button/button/ButtonIcon.js');
require('../inputHeightDictionary-78849349.js');
require('../TooltipContext-20cc2d3d.js');
var Button = require('../Button/Button.js');
require('../SingletonComponent-7ca6baa8.js');
require('../index-6241ea02.js');
require('@tippyjs/react');
var createElementFromAs = require('../createElementFromAs-30a442da.js');
require('lodash/uniqueId');
var index$2 = require('../index-14c98598.js');
require('../FormControl/index.js');
var index$3 = require('../index-497a4b3b.js');
require('../verticalListMarginFromPadding-9f8e64e0.js');
var index$1$2 = require('../List/index.js');
var index$2$1 = require('../ListItem/index.js');
var index$4 = require('../ListDivider/index.js');
var index$5 = require('../ListHeading/index.js');
require('../Popover/popover/TippyPopoverStyles.js');
require('@popperjs/core/lib/utils/computeAutoPlacement');
require('@popperjs/core/lib/utils/detectOverflow');
require('@popperjs/core/lib/utils/getOppositePlacement');
require('@popperjs/core/lib/utils/getOppositeVariationPlacement');
require('../Popover/popover/sizeModifier.js');
var index$6 = require('../Popover/index.js');
var IconArrowDown = require('../icons/IconArrowDown.js');
var downshift = require('downshift');
require('react-dom');
var reactNodeToDownshiftItems = require('./select/reactNodeToDownshiftItems.js');
var useDeepCompareEffect = _interopDefault(require('use-deep-compare-effect'));
var getEffectiveValueFromOptionElementProps = require('./select/getEffectiveValueFromOptionElementProps.js');
var IconCheck = require('../icons/IconCheck.js');

/**
 * Abstraction to handle rendering `ListItem`s with downshift props
 */

var ListItemWrapper = function (_a) {
  var downshiftItems = _a.downshiftItems,
      element = _a.element,
      getItemProps = _a.getItemProps,
      renderListItem = _a.renderListItem,
      selected = _a.selected,
      selectionIndicator = _a.selectionIndicator,
      className = _a.className;
  var index = downshiftItems.indexOf(element.props);

  if (index === -1) {
    throw new Error("Development error: props must be passed by reference in `reactNodeToDownshiftItems` so they can be found with `Array.prototype.indexOf`");
  }

  var downshiftItemProps = getItemProps({
    item: element.props,
    index: downshiftItems.indexOf(element.props),
    disabled: element.props.disabled
  });
  return core.jsx(core.ClassNames, null, function (_a) {
    var css = _a.css,
        cx = _a.cx;
    return renderListItem(_tslib.__assign(_tslib.__assign({
      className: cx(css({
        alignItems: "baseline"
      }), className),
      key: element.props.value || element.props.children
    }, downshiftItemProps), {
      highlighted: downshiftItemProps["aria-selected"] === "true",
      selected: selected,
      startIcon: selectionIndicator === "checkmark" ? selected ? core.jsx(IconCheck.IconCheck, {
        css: {
          height: "100%",
          width: "100%"
        }
      }) : null : undefined,
      children: element.props.children
    }), element);
  });
};

var Select = function (_a) {
  var _b, _c, _d, _e;

  var children = _a.children,
      className = _a.className,
      defaultValue = _a.defaultValue,
      _f = _a.disabled,
      disabled = _f === void 0 ? false : _f,
      feel = _a.feel,
      _g = _a.color,
      color = _g === void 0 ? colors.colors.white : _g,
      labelPropsCallbackRef = _a.labelPropsCallbackRef,
      _h = _a.listAs,
      listAs = _h === void 0 ? core.jsx(index$1$2.List, {
    startIconAs: core.jsx("div", {
      css: {
        alignSelf: "baseline"
      }
    })
  }) : _h,
      _j = _a.margin,
      margin = _j === void 0 ? "auto" : _j,
      matchTriggerWidth = _a.matchTriggerWidth,
      onBlur = _a.onBlur,
      onChange = _a.onChange,
      _k = _a.placement,
      placement = _k === void 0 ? "bottom-start" : _k,
      popperOptions = _a.popperOptions,
      _l = _a.renderListItem,
      renderListItem = _l === void 0 ? function (props) {
    return core.jsx(index$2$1.ListItem, _tslib.__assign({}, props));
  } : _l,
      _m = _a.renderTriggerNode,
      renderTriggerNode = _m === void 0 ? function (value) {
    return core.jsx(React__default.Fragment, null, (value === null || value === void 0 ? void 0 : value.children) || "");
  } : _m,
      _o = _a.selectionIndicator,
      selectionIndicator = _o === void 0 ? null : _o,
      _p = _a.size,
      size = _p === void 0 ? "standard" : _p,
      _q = _a.triggerAs,
      triggerAs = _q === void 0 ? core.jsx(Button.Button, null) : _q,
      _r = _a.truncate,
      truncate = _r === void 0 ? true : _r,
      valueProp = _a.value,
      maxWidth = _a.maxWidth,
      props = _tslib.__rest(_a, ["children", "className", "defaultValue", "disabled", "feel", "color", "labelPropsCallbackRef", "listAs", "margin", "matchTriggerWidth", "onBlur", "onChange", "placement", "popperOptions", "renderListItem", "renderTriggerNode", "selectionIndicator", "size", "triggerAs", "truncate", "value", "maxWidth"]);

  var _s = index$2.useFormControlContext(),
      formControlDescribedBy = _s.describedBy,
      hasError = _s.hasError,
      formControlId = _s.id,
      formControlLabelledBy = _s.labelledBy;

  var id = (_b = props.id) !== null && _b !== void 0 ? _b : formControlId;
  var describedBy = (_c = props["aria-describedby"]) !== null && _c !== void 0 ? _c : formControlDescribedBy;
  var labelledBy = (_d = props["aria-labelledby"]) !== null && _d !== void 0 ? _d : formControlLabelledBy;

  var _t = React__default.useState(defaultValue !== null && defaultValue !== void 0 ? defaultValue : ""),
      uncontrolledValue = _t[0],
      setUncontrolledValue = _t[1]; // Validate controlled versus uncontrolled


  if ((typeof onChange !== "undefined" || typeof valueProp !== "undefined") && typeof defaultValue !== "undefined") {
    // eslint-disable-next-line no-console
    console.warn("Select component must be either controlled or uncontrolled. Pass either `defaultValue` for an uncontrolled component or `value` and optionally `onChange` for a controlled component.");
  }

  var value = typeof valueProp !== "undefined" ? valueProp : uncontrolledValue;
  /**
   * Reference to the underlying popper instance
   *
   * We'll use this to control the popover's visbility based on events captured
   * by downshift
   */

  var instanceRef = React__default.useRef();
  var listConfig = index$3.useListConfig();
  /**
   * Items data represtented by the DOM structure in `children`
   */

  var items = reactNodeToDownshiftItems.reactNodeToDownshiftItems(children);
  /**
   * Ref stored for a timeout that's initiated after a `ToggleButtonClick` state
   * change. It'll automatically clear itself after the timeout. Use this ref
   * containing a value to mean that there was a `ToggleButtonClick` state
   * change in the last tick.
   */

  var toggleButtonClickTimeout = React__default.useRef();
  /**
   * Wrapper to call `onBlur`
   *
   * Will attempt to simulate a real event.
   */

  var blur = function () {
    var target = _tslib.__assign(_tslib.__assign({}, props), {
      value: value
    });

    onBlur === null || onBlur === void 0 ? void 0 : onBlur({
      type: "blur",
      currentTarget: target,
      target: target
    });
  };

  var _u = downshift.useSelect({
    stateReducer: function (state, actionAndChanges) {
      var _a, _b;

      switch (actionAndChanges.type) {
        case downshift.useSelect.stateChangeTypes.MenuMouseLeave:
        case downshift.useSelect.stateChangeTypes.MenuBlur:
          {
            /**
             * Indicates if the element that we "blur"'ed to is a descendent of
             * the tooltip. If it is, then we should bypass the closing behavior.
             */
            var popperContainsActiveElement = !!((_b = (_a = instanceRef.current) === null || _a === void 0 ? void 0 : _a.popper) === null || _b === void 0 ? void 0 : _b.contains(document.activeElement));
            return _tslib.__assign(_tslib.__assign({}, actionAndChanges.changes), {
              isOpen: popperContainsActiveElement
            });
          }

        default:
          return actionAndChanges.changes;
      }
    },
    onStateChange: function (changes) {
      var _a, _b;

      switch (changes.type) {
        case downshift.useSelect.stateChangeTypes.MenuMouseLeave:
        case downshift.useSelect.stateChangeTypes.MenuBlur:
          {
            /**
             * Indicates if the element that we "blur"'ed to is a descendent of
             * the tooltip. If it is, then we should bypass the closing behavior.
             */
            var popperContainsActiveElement = !!((_b = (_a = instanceRef.current) === null || _a === void 0 ? void 0 : _a.popper) === null || _b === void 0 ? void 0 : _b.contains(document.activeElement));
            if (!popperContainsActiveElement) blur();
            break;
          }

        case downshift.useSelect.stateChangeTypes.ToggleButtonClick:
          window.clearTimeout(toggleButtonClickTimeout.current);
          toggleButtonClickTimeout.current = window.setTimeout(function () {
            toggleButtonClickTimeout.current = undefined;
          }, 0);
          break;
      }
    },
    items: items,
    scrollIntoView: function (node) {
      // We have to defer this call until the popover has been created. I really
      // don't have a great explanation for this; but this works and I can't see
      // a downside because the extra complexity.
      setTimeout(function () {
        var _a; // It's silly to write code for our tests, but `scrollIntoView` doesn't
        // exist in JSDOM, so we have to make sure we don't call it on tests or
        // they'll break.


        (_a = node.scrollIntoView) === null || _a === void 0 ? void 0 : _a.call(node, {
          behavior: "auto",
          block: "nearest",
          inline: "nearest"
        });
      }, 0);
    },
    selectedItem: (_e = items.find(function (item) {
      var _a;

      return value === ((_a = item.value) !== null && _a !== void 0 ? _a : item.children);
    })) !== null && _e !== void 0 ? _e : null,
    onSelectedItemChange: function (event) {
      var newValue = event.selectedItem ? getEffectiveValueFromOptionElementProps.getEffectiveValueFromOptionElementProps(event.selectedItem) : "";

      if (onChange) {
        // This is kind of hacky because there's no underlying `select` with
        // native events firing. Maybe we should create them and then fire
        // events?
        var target = _tslib.__assign(_tslib.__assign({}, props), {
          value: newValue
        });

        onChange({
          currentTarget: target,
          target: target
        });
      } else {
        setUncontrolledValue(newValue);
      }
    },
    onIsOpenChange: function (event) {
      var _a, _b;

      if (event.isOpen) {
        (_a = instanceRef.current) === null || _a === void 0 ? void 0 : _a.show();
      } else {
        (_b = instanceRef.current) === null || _b === void 0 ? void 0 : _b.hide();
      }
    }
  }),
      getLabelProps = _u.getLabelProps,
      getItemProps = _u.getItemProps,
      getMenuProps = _u.getMenuProps,
      getToggleButtonProps = _u.getToggleButtonProps,
      selectedItem = _u.selectedItem; // Get the label's props and call the callback ref when they change.


  var labelProps = getLabelProps();
  useDeepCompareEffect(function () {
    labelPropsCallbackRef === null || labelPropsCallbackRef === void 0 ? void 0 : labelPropsCallbackRef(labelProps);
  }, [labelProps, labelPropsCallbackRef]);
  return core.jsx(index$3.ListConfigProvider, _tslib.__assign({}, listConfig, {
    iconSize: "small"
  }), core.jsx(core.ClassNames, null, function (_a) {
    var css = _a.css,
        cx = _a.cx;
    return core.jsx(index$6.Popover, {
      popperOptions: popperOptions,
      onCreate: function (instance) {
        instanceRef.current = instance;
      },
      content: /*#__PURE__*/React__default.cloneElement(listAs, _tslib.__assign(_tslib.__assign(_tslib.__assign({
        margin: margin,
        truncate: truncate
      }, getMenuProps(undefined, {
        suppressRefError: true
      })), id && {
        id: id + "-menu"
      }), {
        "aria-labelledby": labelledBy,
        "aria-describedby": describedBy
      }), React__default.Children.toArray(children) // Filter out falsy elements in `children`. We need to know if
      // we're rendering the first actual element in `children` to
      // know if we should add a divider or not. If the consumer uses
      // conditional logic in their rendering then we could have
      // `undefined` elements in `children`.
      .filter(function (child) {
        return !!child;
      }).map(function (child, topLevelIndex) {
        if (reactNodeToDownshiftItems.isHTMLOptionElement(child)) {
          return core.jsx(ListItemWrapper, {
            className: child.props.className,
            "data-top-level-index": topLevelIndex,
            downshiftItems: items,
            element: child,
            getItemProps: getItemProps,
            renderListItem: renderListItem,
            selected: selectedItem === child.props,
            selectionIndicator: selectionIndicator,
            key: getEffectiveValueFromOptionElementProps.getEffectiveValueFromOptionElementProps(child.props)
          });
        } else if (reactNodeToDownshiftItems.isHTMLOptgroupElement(child)) {
          return core.jsx(React__default.Fragment, {
            key: child.props.label
          }, topLevelIndex > 0 && core.jsx(index$4.ListDivider, {
            "data-top-level-index": topLevelIndex
          }), child.props.label && core.jsx(index$5.ListHeading, {
            "aria-label": child.props.label,
            role: "group"
          }, child.props.label), React__default.Children.map(child.props.children, function (optgroupChild) {
            return core.jsx(ListItemWrapper, {
              key: getEffectiveValueFromOptionElementProps.getEffectiveValueFromOptionElementProps(optgroupChild.props),
              downshiftItems: items,
              element: optgroupChild,
              getItemProps: getItemProps,
              renderListItem: renderListItem,
              selectionIndicator: selectionIndicator,
              selected: selectedItem === optgroupChild.props
            });
          }));
        }

        return null;
      })),
      hideOnClick: false,
      placement: placement,
      triggerEvents: "manual",
      matchTriggerWidth: matchTriggerWidth,
      trigger: /*#__PURE__*/React__default.cloneElement(createElementFromAs.createElementFromAs(triggerAs), _tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign({}, getToggleButtonProps({
        disabled: disabled
      })), props), labelledBy && {
        "aria-labelledby": labelledBy
      }), {
        id: id,
        className: cx(css({
          border: hasError ? "1px solid " + colors.colors.red.base : undefined,
          textAlign: "left"
        }), className, /*#__PURE__*/React__default.isValidElement(triggerAs) && triggerAs.props.className),
        color: color,
        feel: feel,
        onBlur: function () {
          if (toggleButtonClickTimeout.current) {
            // There was a `ToggleButtonClick` state change in the last
            // tick, so ignore this blur call.
            return;
          }

          blur();
        },
        type: "button",
        size: size,
        endIcon: core.jsx(IconArrowDown.IconArrowDown, {
          className: css({
            height: "70%"
          }),
          weight: "thin"
        })
      }), core.jsx("div", {
        className: css({
          flex: 1,
          overflow: "hidden",
          whiteSpace: "nowrap",
          textOverflow: "ellipsis"
        })
      }, renderTriggerNode(selectedItem))),
      maxWidth: maxWidth
    });
  }));
};

exports.Select = Select;
//# sourceMappingURL=index.js.map
