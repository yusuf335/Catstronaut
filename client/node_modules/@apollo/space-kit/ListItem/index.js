'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _tslib = require('../_tslib-bcbe0269.js');
var core = require('@emotion/core');
var React = require('react');
var React__default = _interopDefault(React);
var colors = require('../colors/colors.js');
var assertUnreachable = require('../assertUnreachable-698a501a.js');
var tinycolor = _interopDefault(require('tinycolor2'));
var index = require('../index-497a4b3b.js');
var verticalListMarginFromPadding = require('../verticalListMarginFromPadding-9f8e64e0.js');

/**
 * Clone elements in order. All `className`, `style`, and `css` props will be
 * propogated and merged. The leftmost `ref` will be maintained.
 */

var cloneElements = function () {
  var elements = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    elements[_i] = arguments[_i];
  }

  return /*#__PURE__*/React__default.createElement(core.ClassNames, null, function (_a) {
    var css = _a.css,
        cx = _a.cx;
    if (elements.length === 1) return elements[0];
    return elements.reduce(function (accumulator, element) {
      var _a;

      return /*#__PURE__*/React__default.cloneElement(accumulator, _tslib.__assign(_tslib.__assign({}, element.props), {
        className: cx(element.props.className, accumulator.props.className, // If the parent component is using emotion with the jsx pragma, we
        // have to get fancy and intercept the styles to use with the
        // `ClassNames` wrapper.
        accumulator.props.css ? css(accumulator.props.css.styles) : null),
        style: _tslib.__assign(_tslib.__assign({}, element.props.style), accumulator.props.style),
        // Since we're cloning `as` with the `original` props added, we're
        // going to lose the `ref`. We have to grab it from the
        // `React.ReactElement` instance
        ref: (_a = accumulator.ref) !== null && _a !== void 0 ? _a : element.ref
      }));
    });
  });
};

function getIconHorizontalPadding(iconSize) {
  switch (iconSize) {
    case "large":
      return 16;

    case "normal":
      return 12;

    case "small":
      return 8;

    default:
      assertUnreachable.assertUnreachable(iconSize);
  }
}

function getIconSize(iconSize) {
  switch (iconSize) {
    case "large":
      return 18;

    case "normal":
      return 16;

    case "small":
      return 10;

    default:
      assertUnreachable.assertUnreachable(iconSize);
  }
}

function getIconMarginLeft(iconSize) {
  switch (iconSize) {
    case "large":
    case "normal":
      return "initial";

    case "small":
      return -7;

    default:
      assertUnreachable.assertUnreachable(iconSize);
  }
}

var ListItem = /*#__PURE__*/React__default.forwardRef(function (_a, ref) {
  var _b = _a.as,
      as = _b === void 0 ? /*#__PURE__*/React__default.createElement("div", null) : _b,
      children = _a.children,
      endIcon = _a.endIcon,
      endIconAsProp = _a.endIconAs,
      _c = _a.highlighted,
      highlighted = _c === void 0 ? false : _c,
      _d = _a.interactive,
      interactive = _d === void 0 ? true : _d,
      _e = _a.selected,
      selected = _e === void 0 ? false : _e,
      startIcon = _a.startIcon,
      startIconAsProp = _a.startIconAs,
      props = _tslib.__rest(_a, ["as", "children", "endIcon", "endIconAs", "highlighted", "interactive", "selected", "startIcon", "startIconAs"]);

  var _f = index.useListConfig(),
      hoverColor = _f.hoverColor,
      iconSize = _f.iconSize,
      margin = _f.margin,
      padding = _f.padding,
      selectedColor = _f.selectedColor,
      truncate = _f.truncate,
      listConfig = _tslib.__rest(_f, ["hoverColor", "iconSize", "margin", "padding", "selectedColor", "truncate"]);

  var endIconAs = endIconAsProp !== null && endIconAsProp !== void 0 ? endIconAsProp : listConfig.endIconAs;
  var startIconAs = startIconAsProp !== null && startIconAsProp !== void 0 ? startIconAsProp : listConfig.startIconAs;
  var selectedTextColor = tinycolor.mostReadable(selectedColor, [colors.colors.white, colors.colors.grey.darker], {
    level: "AA",
    size: "small"
  }).toString();
  var selectedBackgroundColor = selectedColor;
  var selectedStyles = interactive && {
    backgroundColor: selectedBackgroundColor,
    color: selectedTextColor
  };
  var highlightedStyles = hoverColor && interactive && {
    backgroundColor: hoverColor,
    color: tinycolor.mostReadable(hoverColor, [colors.colors.white, colors.colors.grey.darker], {
      level: "AA",
      size: "small"
    }).toString()
  };
  var verticalMargin = verticalListMarginFromPadding.verticalListMarginFromPadding(padding) / 2;
  return /*#__PURE__*/React__default.createElement(core.ClassNames, null, function (_a) {
    var css = _a.css,
        cx = _a.cx;
    return cloneElements(as, /*#__PURE__*/React__default.createElement("div", _tslib.__assign({}, props, {
      className: cx(css(_tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign({}, selected && selectedStyles), {
        "&[aria-expanded=true]": selectedStyles
      }), !selected && {
        "&:hover, &[data-force-hover-state]": highlightedStyles
      }), highlighted && !selected && highlightedStyles), {
        alignItems: "center",
        cursor: interactive ? "pointer" : undefined,
        borderRadius: margin === "auto" ? 4 : margin === "none" ? 0 : assertUnreachable.assertUnreachable(margin),
        display: "flex",
        height: !truncate ? "auto" : padding === "normal" ? 28 : padding === "relaxed" ? 40 : assertUnreachable.assertUnreachable(padding),
        paddingLeft: 12 + (margin === "none" ? 6 : margin === "auto" ? 0 : assertUnreachable.assertUnreachable(margin)),
        paddingRight: 12 + (margin === "none" ? 6 : margin === "auto" ? 0 : assertUnreachable.assertUnreachable(margin)),
        paddingTop: 4,
        paddingBottom: 4,
        marginTop: verticalMargin,
        marginBottom: verticalMargin
      })), props.className),
      ref: ref
    }), typeof startIcon !== "undefined" && cloneElements(startIconAs, /*#__PURE__*/React__default.createElement("div", {
      className: cx(css({
        alignSelf: "center",
        display: "flex",
        flex: "none",
        marginLeft: getIconMarginLeft(iconSize),
        marginRight: getIconHorizontalPadding(iconSize),
        overflow: "hidden",
        whiteSpace: "nowrap",
        width: getIconSize(iconSize)
      }))
    }, startIcon)), /*#__PURE__*/React__default.createElement("div", {
      className: cx(css({
        flex: "1",

        /* This is weird but it's necessary to truncate list items */
        minWidth: 0,
        overflow: "hidden",
        textOverflow: "ellipsis"
      }), truncate && css({
        whiteSpace: "nowrap"
      }))
    }, children), typeof endIcon !== "undefined" && cloneElements(endIconAs, /*#__PURE__*/React__default.createElement("div", {
      className: cx(css({
        alignSelf: "center",
        display: "flex",
        flex: "none",
        justifyContent: "flex-end",
        marginLeft: getIconHorizontalPadding(iconSize),
        overflow: "hidden",
        whiteSpace: "nowrap",
        width: getIconSize(iconSize)
      }))
    }, endIcon))));
  });
});

exports.ListItem = ListItem;
//# sourceMappingURL=index.js.map
